name: 'Claude Code PR Review'
description: 'Composite action for automated PR review using Claude Code with AWS Bedrock'
author: 'Anthropic'
branding:
  icon: 'check-circle'
  color: 'orange'

inputs:
  custom_review_instructions:
    description: 'Custom review instructions to append to the base prompt'
    required: false
    default: ''
  allowed_tools:
    description: 'Comma-separated list of tools to allow during the review'
    required: false
    default: ''
  disallowed_tools:
    description: 'Comma-separated list of tools to disallow during the review'
    required: false
    default: ''

runs:
  using: 'composite'
  steps:
  # Get PR info for fork support - must happen before checkout
  - name: Get PR info for fork support
    if: github.event.issue.pull_request
    id: pr-info
    shell: bash
    env:
      GH_TOKEN: ${{ github.token }}
    run: |
      PR_DATA=$(gh api repos/${{ github.repository }}/pulls/${{ github.event.issue.number }})
      echo "pr_head_owner=$(echo "$PR_DATA" | jq -r '.head.repo.owner.login')" >> $GITHUB_OUTPUT
      echo "pr_head_repo=$(echo "$PR_DATA" | jq -r '.head.repo.name')" >> $GITHUB_OUTPUT
      echo "pr_head_ref=$(echo "$PR_DATA" | jq -r '.head.ref')" >> $GITHUB_OUTPUT
      echo "is_fork=$(echo "$PR_DATA" | jq -r '.head.repo.fork')" >> $GITHUB_OUTPUT

  # Checkout repository (works for both fork and non-fork PRs)
  - name: Checkout repository
    uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
    with:
      repository: ${{ github.event.issue.pull_request && steps.pr-info.outputs.is_fork == 'true' && format('{0}/{1}', steps.pr-info.outputs.pr_head_owner, steps.pr-info.outputs.pr_head_repo) || github.repository }}
      ref: ${{ github.event.issue.pull_request && steps.pr-info.outputs.pr_head_ref || github.ref }}
      fetch-depth: 0

  # For fork PRs, add base repo as upstream and ensure branch is trackable
  - name: Configure remotes for fork PR
    if: github.event.issue.pull_request && steps.pr-info.outputs.is_fork == 'true'
    shell: bash
    run: |
      echo "Adding base repository as upstream remote"
      git remote add upstream https://github.com/${{ github.repository }}.git
      git fetch upstream --quiet

      # Ensure the fork branch exists as a remote ref that claude-code-action can find
      echo "Ensuring branch ${{ steps.pr-info.outputs.pr_head_ref }} is available"
      git branch --set-upstream-to=origin/${{ steps.pr-info.outputs.pr_head_ref }} ${{ steps.pr-info.outputs.pr_head_ref }} 2>/dev/null || true

      echo "Current branch and remotes:"
      git branch -vv
      git remote -v

  - name: Copy Claude config to home directory
    shell: bash
    run: |
      set -e

      if [ -d "${GITHUB_ACTION_PATH}/.claude" ]; then
        echo "Copying Claude config from ${GITHUB_ACTION_PATH}/.claude to ~/.claude"
        cp -r "${GITHUB_ACTION_PATH}/.claude" ~/.claude
        ls -la ~/.claude/agents
        echo "Claude config copied successfully"
      else
        echo "No .claude directory found at ${GITHUB_ACTION_PATH}/.claude - skipping agent setup"
        exit 1
      fi

  - name: Get diff
    shell: bash
    env:
      GH_TOKEN: ${{ github.token }}
      PR_NUMBER: "${{ github.event.issue.number || github.event.pull_request.number }}"
    run: ${GITHUB_ACTION_PATH}/scripts/diff.sh

  - name: Hide Previous Reviews
    shell: bash
    if: |
      (github.event_name == 'issue_comment' && github.event.comment.body == '@claude') ||
      (github.event_name == 'pull_request_review' && github.event.review.body == '@claude')
    env:
      GH_TOKEN: ${{ github.token }}
      PR_NUMBER: "${{ github.event.issue.number || github.event.pull_request.number }}"
    run: ${GITHUB_ACTION_PATH}/scripts/hide-previous-reviews.sh

  - name: Set up Python
    uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
    with:
      python-version: '3.11'

  - name: Install uv
    shell: bash
    run: |
      python -m pip install --upgrade pip
      python -m pip install uv==0.6.11
      uv --version

  - name: Configure AWS Credentials (OIDC)
    uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2
    with:
      role-to-assume: arn:aws:iam::340752820498:role/auth0-bedrock-github-actions-pr-analyzer
      role-session-name: bedrock-pr-analyzer
      aws-region: us-east-1

  - name: Trigger Claude Code
    uses: anthropics/claude-code-action@ac1a3207f3f00b4a37e2f3a6f0935733c7c64651  # v1.0.11
    with:
      use_bedrock: 'true'
      track_progress: 'true'
      github_token: ${{ github.token }}
      claude_args: |
        --model arn:aws:bedrock:us-east-1:340752820498:inference-profile/us.anthropic.claude-sonnet-4-5-20250929-v1:0
        --allowedTools "Bash(git add:*),
          Bash(git commit:*),
          Bash(git push:*),
          Bash(git status:*),
          Bash(git rm:*),
          Bash(git log:*),
          Bash(ls:*),
          Bash(cat diff.txt),
          Edit,
          MultiEdit,
          Glob,
          Grep,
          LS,
          Read,
          Write,
          ${{ inputs.allowed_tools != '' && format('{0},', inputs.allowed_tools) || '' }}
          mcp__github_inline_comment__create_inline_comment"
        --disallowedTools "Bash(git diff:*),
          Bash(git pr diff:*),
          Read(vendor),
          Read(package-lock.json),
          ${{ inputs.disallowed_tools != '' && format('{0},', inputs.disallowed_tools) || '' }}
          Read(dist)"
      prompt: |
        In case the user is asking for a review, follow the following instructions:

        1. First, understand the PR context:
          - Run Bash(cat diff.txt) to get the diff
        2. Read AGENTS.md to understand the context and architecture of this project before the review.
        3. Perform a code quality review
        4. Perform a security review
        5. Perform a performance review
        6. Use `mcp__github_inline_comment__create_inline_comment` to provide feedback for specific issues
          - When writing a code suggestion, take into account that the code between startLine and line will be replaced by your suggestion
          - For single-line comments: Replace ONLY the affected line
          - For multi-line comments: Replace ONLY the lines in the range (startLine, line)
        7. Update your comment with `mcp__github_comment__update_claude_comment` with a single paragraph with a description if the PR is ready to be merged or not.
          - DO NOT list which issues must be fixed, just a high-level summary of the PR status.

        <summary_example>
          ## Overall Assessment
          ✅ {very short description if the pull request is ready to be merged, and nothing else}
          ❌ {very short description if the pull request is not ready to be merged, and nothing else}
        </summary_example>

        <review_guidelines>
          ${{ inputs.custom_review_instructions }}

          - CRITICAL: ONLY provide feedback on issues that need to be addressed or improved. NEVER include praise, positive observations, or acknowledgments of good practices. NEVER comment with any acknowledgment of correct code.
          - CRITICAL: When writing a suggestion block, PRESERVE THE EXACT INDENTATION of the original code! DO NOT remove spaces, tabs, or any whitespace at the beginning of lines! The suggestion MUST maintain the same indentation level as the replaced code!
          - CRITICAL: Before suggesting code replacement, verify that all referenced functions, variables, and imports exist in the current file or are being added in your suggestion
          - CRITICAL: If your suggestion introduces new helper functions, you should include the complete function definition in your comment (not as a code suggestion)
          - CRITICAL: When suggesting changes to function parameters or signatures, ensure the entire function declaration and body are included in the suggestion
          - CRITICAL: Always consider the context of surrounding code - if a line is part of a larger code block (function, if-statement, loop), include enough context to maintain syntactic validity
          - CRITICAL: If suggesting a multi-line replacement for complex logic, ensure all necessary imports, variable declarations, and function definitions are included
          - CRITICAL: Test your suggested code mentally for syntax errors, missing semicolons, unmatched braces, undefined variables, and missing imports before providing the suggestion
          - CRITICAL: FUNCTIONAL EQUIVALENCE - Your suggestion must maintain the exact same program behavior and logic flow. Do not change algorithms, error handling patterns, or execution order unless explicitly addressing a bug
          - CRITICAL: COMPILATION VERIFICATION - Before suggesting any code replacement, mentally verify that the suggested code will compile and run without errors in the existing codebase context 
          - CRITICAL: SCOPE LIMITATION - Only suggest code changes that fix the specific issue identified. Do not refactor or improve unrelated aspects of the code in the same suggestion
          - CRITICAL: DEPENDENCY VALIDATION - Verify that all functions, methods, variables, types, and imports used in your suggestion are available in the current file's scope or standard library
          - CRITICAL: If you identify an issue but cannot provide a safe, functionally equivalent replacement within the line range, provide the feedback as a comment without a code suggestion block
        </review_guidelines>

        <security_review>
          **Security Vulnerability Assessment**

          - Systematically scan for OWASP Top 10 vulnerabilities (injection flaws, broken authentication, sensitive data exposure, XXE, broken access control, security misconfiguration, XSS, insecure deserialization, using components with known vulnerabilities, insufficient logging)
          - Identify potential SQL injection, NoSQL injection, and command injection vulnerabilities
          - Check for cross-site scripting (XSS) vulnerabilities in any user-facing output
          - Look for cross-site request forgery (CSRF) protection gaps
          - Examine cryptographic implementations for weak algorithms or improper key management
          - Identify potential race conditions and time-of-check-time-of-use (TOCTOU) vulnerabilities

          **Input Validation and Sanitization**

          - Verify all user inputs are properly validated against expected formats and ranges
          - Ensure input sanitization occurs at appropriate boundaries (client-side validation is supplementary, never primary)
          - Check for proper encoding when outputting user data
          - Validate that file uploads have proper type checking, size limits, and content validation
          - Ensure API parameters are validated for type, format, and business logic constraints
          - Look for potential path traversal vulnerabilities in file operations

          **Authentication and Authorization Review**

          - Verify authentication mechanisms use secure, industry-standard approaches
          - Check for proper session management (secure cookies, appropriate timeouts, session invalidation)
          - Validate that authorization checks occur at every protected resource access
          - Look for privilege escalation opportunities
          - Check for insecure direct object references (IDOR)
          - Verify proper implementation of role-based or attribute-based access control

          **Analysis Methodology**

          1. First, identify the security context and attack surface of the code
          2. Map data flows from untrusted sources to sensitive operations
          3. Examine each security-critical operation for proper controls
          4. Consider both common vulnerabilities and context-specific threats
          5. Evaluate defense-in-depth measures
        </security_review>

        <performance_review>
          **Performance Bottleneck Analysis:**

          - Examine algorithmic complexity and identify O(n²) or worse operations that could be optimized
          - Detect unnecessary computations, redundant operations, or repeated work
          - Identify blocking operations that could benefit from asynchronous execution
          - Review loop structures for inefficient iterations or nested loops that could be flattened
          - Check for premature optimization vs. legitimate performance concerns

          **Network Query Efficiency:**

          - Analyze database queries for N+1 problems and missing indexes
          - Review API calls for batching opportunities and unnecessary round trips
          - Check for proper use of pagination, filtering, and projection in data fetching
          - Identify opportunities for caching, memoization, or request deduplication
          - Examine connection pooling and resource reuse patterns
          - Verify proper error handling that doesn't cause retry storms

          **Memory and Resource Management:**

          - Detect potential memory leaks from unclosed connections, event listeners, or circular references
          - Review object lifecycle management and garbage collection implications
          - Identify excessive memory allocation or large object creation in loops
          - Check for proper cleanup in cleanup functions, destructors, or finally blocks
          - Analyze data structure choices for memory efficiency
          - Review file handles, database connections, and other resource cleanup
        </performance_review>

        <code_quality>
          **Clean Code Analysis:**

          - Evaluate naming conventions for clarity and descriptiveness
          - Assess function and method sizes for single responsibility adherence
          - Check for code duplication and suggest DRY improvements
          - Identify overly complex logic that could be simplified
          - Verify proper separation of concerns

          **Error Handling & Edge Cases:**

          - Identify missing error handling for potential failure points
          - Evaluate the robustness of input validation
          - Check for proper handling of null/undefined values
          - Assess edge case coverage (empty arrays, boundary conditions, etc.)
          - Verify appropriate use of try-catch blocks and error propagation

          **Readability & Maintainability:**

          - Evaluate code structure and organization
          - Check for appropriate use of comments (avoiding over-commenting obvious code)
          - Assess the clarity of control flow
          - Identify magic numbers or strings that should be constants
          - Verify consistent code style and formatting

          **Best Practices:**

          - Evaluate adherence to SOLID principles
          - Check for proper use of design patterns where appropriate
          - Assess performance implications of implementation choices
          - Verify security considerations (input sanitization, sensitive data handling)
        </code_quality>
